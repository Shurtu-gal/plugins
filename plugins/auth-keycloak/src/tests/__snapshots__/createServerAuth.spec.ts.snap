// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Testing afterCreateAuth hook should create all the auth modules 1`] = `
[
  {
    "code": "import { Injectable } from "@nestjs/common";
import { JwtStrategyBase } from "./base/jwt.strategy.base";
import { ConfigService } from "@nestjs/config";
import { KeycloakPayload } from "./base/types";
import { IAuthStrategy } from "../IAuthStrategy";
import { UserInfo } from "../UserInfo";
import { UserService } from "src/user/user.service";
import { EnumUserPriority } from "../../user/base/EnumUserPriority";

@Injectable()
export class JwtStrategy extends JwtStrategyBase implements IAuthStrategy {
  constructor(
    protected readonly configService: ConfigService,
    protected readonly userService: UserService
  ) {
    super(configService, userService);
  }

  async validate(payload: KeycloakPayload): Promise<UserInfo> {
    const validatedUser = await this.validateBase(payload);

    // Validate if the user is authorized to the specified client
    if (payload.azp !== this.configService.get<string>("KEYCLOAK_CLIENT_ID")) {
      throw new Error("Invalid token");
    }

    // If the entity is valid, return it
    if (validatedUser) {
      if (
        !Array.isArray(validatedUser.roles) ||
        typeof validatedUser.roles !== "object" ||
        validatedUser.roles === null
      ) {
        throw new Error("ENTITY roles is not a valid value");
      }

      return validatedUser;
    }

    // Otherwise, make a new entity and return it
    const userFields = payload;
    const defaultData = {
      email: userFields.email,
      priority: EnumUserPriority.High
    };

    const newUser = await this.userService.createUser({
      data: defaultData,
    });

    return { ...newUser, roles: newUser?.roles as string[] };
  }
}
",
    "path": "src/auth/jwt/jwt.strategy.ts",
  },
  {
    "code": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { UnauthorizedException } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import { PassportStrategy } from "@nestjs/passport";
import { passportJwtSecret } from "jwks-rsa";
import { ExtractJwt, Strategy } from "passport-jwt";
import { KeycloakPayload } from "./types";
import { UserInfo } from "../../UserInfo";
import { UserService } from "src/user/user.service";

export class JwtStrategyBase extends PassportStrategy(Strategy) {
  constructor(
    protected readonly configService: ConfigService,
    protected readonly userService: UserService
  ) {
    const url = configService.get<string>("KEYCLOAK_URL");
    const realm = configService.get<string>("KEYCLOAK_REALM");
    const issuerURL = \`\${url}/realms/\${realm}\`;

    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Extract JWT from the Authorization header
      issuer: issuerURL,

      secretOrKeyProvider: passportJwtSecret({
        cache: true,
        rateLimit: true,
        jwksRequestsPerMinute: 5,
        jwksUri: \`\${issuerURL}/protocol/openid-connect/certs\`,
      }),
    });
  }

  // Validate the received JWT and construct the user object out of the decoded token.
  async validateBase(
    payload: KeycloakPayload
  ): Promise<UserInfo | null> {
    const user = await this.userService.user({
      where: {
        email: payload.email,
      },
    });

    return user ? { ...user, roles: user?.roles as string[] } : null;
  }
}",
    "path": "src/auth/jwt/base/jwt.strategy.base.ts",
  },
  {
    "code": "import { Module, forwardRef } from "@nestjs/common";
import { PassportModule } from "@nestjs/passport";
import { JwtStrategy } from "./jwt/jwt.strategy";
import { UserModule } from "../user/user.module";

@Module({
  imports: [
    forwardRef(() => UserModule),
    PassportModule.register({ defaultStrategy: "jwt" }),
  ],
  providers: [JwtStrategy],
  controllers: [],
  exports: [PassportModule],
})
export class AuthModule {}
",
    "path": "src/auth/auth.module.ts",
  },
  {
    "code": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import { Query, Resolver } from "@nestjs/graphql";
import * as gqlACGuard from "../auth/gqlAC.guard";
import { GqlDefaultAuthGuard } from "./gqlDefaultAuth.guard";
import { UserData } from "./userData.decorator";
import { UserInfo } from "./UserInfo";

@Resolver(UserInfo)
export class AuthResolver {
  @Query(() => UserInfo)
  @common.UseGuards(GqlDefaultAuthGuard, gqlACGuard.GqlACGuard)
  async userInfo(
    @UserData() entityInfo: UserInfo
  ): Promise<UserInfo> {
    return entityInfo;
  }
}",
    "path": "src/auth/auth.resolver.ts",
  },
  {
    "code": "import { Observable } from "rxjs";
import { ExecutionContext, Injectable } from "@nestjs/common";
import { Reflector } from "@nestjs/core";
import { IS_PUBLIC_KEY } from "../decorators/public.decorator";
import { JwtAuthGuard } from "./jwt/jwtAuth.guard";

@Injectable()
export class DefaultAuthGuard extends JwtAuthGuard {
  constructor(private readonly reflector: Reflector) {
    super();
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<any> {
    const isPublic = this.reflector.get<boolean>(
      IS_PUBLIC_KEY,
      context.getHandler(),
    );

    if (isPublic) {
      return true;
    }

    return super.canActivate(context);
  }
}
",
    "path": "src/auth/defaultAuth.guard.ts",
  },
  {
    "code": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
*/

export interface KeycloakPayload {
  iss: string; // issuer
  sub: string; // subject
  azp: string; // authorized party
  scope: string; // scope
  email_verified: boolean;
  name: string;
  preferred_username: string;
  given_name: string;
  family_name: string;
  email: string;
  realm_access: {
    roles: string[];
  };
}
",
    "path": "src/auth/jwt/base/types.ts",
  },
  {
    "code": "import { ExecutionContext } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";
import { Observable } from "rxjs";

export class JwtAuthGuard extends AuthGuard("jwt") {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const promiseOrBoolean = super.canActivate(context);
    if (promiseOrBoolean instanceof Promise) {
      return promiseOrBoolean.then((result) => {
        return result;
      });
    } else {
      return promiseOrBoolean;
    }
  }
}
",
    "path": "src/auth/jwt/jwtAuth.guard.ts",
  },
  {
    "code": "{
  "realm": "amplication-sample-realm",
  "displayName": "Amplication Sample Realm",
  "displayNameHtml": "Amplication Sample Realm",
  "notBefore": 0,
  "defaultSignatureAlgorithm": "RS256",
  "enabled": true,
  "sslRequired": "external",
  "registrationAllowed": true,
  "registrationEmailAsUsername": false,
  "rememberMe": false,
  "verifyEmail": false,
  "loginWithEmailAllowed": true,
  "duplicateEmailsAllowed": false,
  "resetPasswordAllowed": true,
  "editUsernameAllowed": false,
  "requiredCredentials": [
    "password"
  ],
  "clients": [
    {
      "clientId": "amplication-server",
      "name": "Amplication Server",
      "description": "Sample client for Amplication Server",
      "rootUrl": "http://localhost:3001/",
      "adminUrl": "http://localhost:8080",
      "baseUrl": "http://localhost:3001/",
      "surrogateAuthRequired": false,
      "enabled": true,
      "alwaysDisplayInConsole": true,
      "clientAuthenticatorType": "client-secret",
      "redirectUris": [
        "http://localhost:3001/*"
      ],
      "webOrigins": [
        "+" 
      ],
      "notBefore": 0,
      "bearerOnly": false,
      "consentRequired": false,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": true,
      "serviceAccountsEnabled": false,
      "publicClient": true,
      "frontchannelLogout": true,
      "protocol": "openid-connect",
      "attributes": {
        "oidc.ciba.grant.enabled": "false",
        "post.logout.redirect.uris": "http://localhost:3001/*",
        "oauth2.device.authorization.grant.enabled": "false",
        "backchannel.logout.session.required": "true",
        "backchannel.logout.revoke.offline.tokens": "false"
      },
      "authenticationFlowBindingOverrides": {},
      "fullScopeAllowed": true,
      "nodeReRegistrationTimeout": -1,
      "defaultClientScopes": [
        "web-origins",
        "acr",
        "roles",
        "profile",
        "email"
      ],
      "optionalClientScopes": [
        "address",
        "phone",
        "offline_access",
        "microprofile-jwt"
      ]
    }
  ],
  "internationalizationEnabled": false,
  "keycloakVersion": "22.0.5"
}",
    "path": "src/keycloak/realm-export.json",
  },
]
`;
